"""
Shared protocols for algorithms and data access.
"""

from __future__ import annotations

from typing import (
    Protocol,
    List,
    Tuple,
    Optional,
    TypeVar,
    Generic,
    Dict,
    Iterator,
    Any,
)
from pathlib import Path

from .types import (
    Document,
    Finding,
    LibraryDocument,
    LibraryDocumentWFindings,
    EmbedderSpec,
    ChunkerSpec,
)

T = TypeVar("T")


class Chunker(Protocol):
    @property
    def spec(self) -> ChunkerSpec: ...
    
    def chunk(self, text: str) -> List[str]: ...


class Embedder(Protocol):
    @property
    def spec(self) -> EmbedderSpec: ...

    def embed(self, texts: List[str]) -> List[List[float]]: ...


class AnnIndex(Protocol):
    def add(self, doc_id: str, chunk_ids: List[int], vectors: List[List[float]]) -> None: ...
    def query(self, q: List[float], top_k: int) -> List[Tuple[str, int, float]]: ...
    def persist(self, path: Path) -> None: ...
    def load(self, path: Path) -> None: ...


class Corpus(Protocol):
    """Protocol for corpus handles that provide read access to document corpora."""
    
    def list_ids(self) -> List[str]: ...
    def get_text(self, doc_id: str) -> str: ...
    def get_metadata(self, doc_id: str) -> Dict[str, Any]: ...
    def get_fetch_info(self, doc_id: str) -> Dict[str, Any]: ...
    def get_document(self, doc_id: str) -> Optional[Document]: ...
    def iter_documents(self) -> Iterator[Document]: ...
    def get_document_count(self) -> int: ...
    def get_corpus_info(self) -> Dict[str, Any]: ...
    def fingerprint(self, doc_id: str) -> str: ...
    def load_manifest(self) -> Dict[str, Any]: ...


class Library(Protocol):
    """Protocol for library handles that provide read access to findings libraries."""
    
    def iter_documents(self) -> Iterator[LibraryDocumentWFindings]: ...
    def iter_findings(self) -> Iterator[Finding]: ...
    def get_finding(self, finding_id: str) -> Optional[Finding]: ...
    def get_document_for_finding(self, finding_id: str) -> Optional[LibraryDocumentWFindings]: ...
    def get_findings_count(self) -> int: ...
    def get_layout_info(self) -> Dict[str, Any]: ...
    def get_library_info(self) -> Dict[str, Any]: ...
    def search_findings(self, query: str, case_sensitive: bool = False) -> Iterator[LibraryDocumentWFindings]: ...
    def filter_by_category(self, category: str) -> Iterator[LibraryDocumentWFindings]: ...
    def filter_by_confidence(self, min_confidence: float) -> Iterator[LibraryDocumentWFindings]: ...



class LibraryStore(Protocol):
    """Protocol for library stores that provide read/write access to findings data."""
    
    def store_findings(self, findings: LibraryDocumentWFindings) -> bool: ...
    def get_findings_by_url(self, url: str) -> Optional[LibraryDocumentWFindings]: ...
    def get_findings_by_doc_id(self, doc_id: str) -> Optional[LibraryDocumentWFindings]: ...
    def list_all_findings(self) -> List[LibraryDocumentWFindings]: ...
    def search_findings(self, query: str) -> List[LibraryDocumentWFindings]: ...
    def get_storage_stats(self) -> dict: ...


class LibraryBuilder(Protocol):
    """Protocol for library builders that create findings libraries."""
    
    def build_library(self, max_sources: Optional[int] = None) -> dict: ...
    def get_library_stats(self) -> dict: ...
    def search_library(self, query: str) -> List[LibraryDocumentWFindings]: ...
    def export_library(self, export_path: Optional[Path] = None) -> Path: ...
    def clear_cache(self) -> None: ...
    def close(self) -> None: ...

